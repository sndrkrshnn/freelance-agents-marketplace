name: Reusable Docker Build

on:
  workflow_call:
    inputs:
      docker-context:
        required: true
        type: string
      dockerfile:
        required: false
        type: string
        default: Dockerfile
      image-name:
        required: true
        type: string
      image-tags:
        required: true
        type: string
        description: "Comma-separated tags for the image (e.g., latest,sha-${GITHUB_SHA})"
      push:
        required: false
        type: boolean
        default: true
      cache-from:
        required: false
        type: string
        default: type=gha
      cache-to:
        required: false
        type: string
        default: type=gha,mode=max
      registry:
        required: false
        type: string
        default: ghcr.io
      build-args:
        required: false
        type: string
        description: "JSON object of build args (e.g., '{\"NODE_VERSION\":\"18\"}')"
      platforms:
        required: false
        type: string
        description: "Comma-separated platforms (e.g., linux/amd64,linux/arm64)"
      target:
        required: false
        type: string
        description: "Docker build target stage"

    outputs:
      image-digest:
        value: ${{ jobs.build.outputs.digest }}
      image-ref:
        value: ${{ jobs.build.outputs.ref }}
      build-time:
        value: ${{ jobs.build.outputs.build_time }}

    secrets:
      registry-username:
        required: false
      registry-password:
        required: false

jobs:
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      digest: ${{ steps.build.outputs.digest }}
      ref: ${{ steps.meta.outputs.tags }}
      build_time: ${{ steps.time.outputs.timestamp }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Get current timestamp
        id: time
        run: |
          echo "timestamp=$(date -u +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
      
      - name: Set up QEMU
        if: inputs.platforms != ''
        uses: docker/setup-qemu-action@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: ${{ inputs.platforms }}
      
      - name: Login to registry
        if: inputs.push == true
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ secrets.registry-username || github.actor }}
          password: ${{ secrets.registry-password || github.token }}
      
      - name: Set up build args
        id: build-args
        env:
          BUILD_ARGS_JSON: ${{ inputs.build-args }}
        run: |
          ARGS="VERSION=${{ github.ref_name }},COMMIT_SHA=${{ github.sha }},BUILD_DATE=${{ steps.time.outputs.timestamp }}"
          
          if [ -n "$BUILD_ARGS_JSON" ]; then
            ADDITIONAL_ARGS=$(echo "$BUILD_ARGS_JSON" | jq -r 'to_entries | map("\(.key)=\(.value)") | join(",")')
            args="${ADDITIONAL_ARGS},${ARGS}"
          fi
          
          echo "args=${args}" >> $GITHUB_OUTPUT
      
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.docker-context }}
          file: ${{ inputs.docker-context }}/${{ inputs.dockerfile }}
          push: ${{ inputs.push }}
          tags: |
            ${{ inputs.image-name }}:${{ inputs.image-tags }}
          labels: |
            org.opencontainers.image.title=${{ inputs.image-name }}
            org.opencontainers.image.description=Built from ${{ github.repository }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ steps.time.outputs.timestamp }}
            org.opencontainers.image.version=${{ github.ref_name }}
          cache-from: ${{ inputs.cache-from }}
          cache-to: ${{ inputs.cache-to }}
          build-args: ${{ steps.build-args.outputs.args }}
          platforms: ${{ inputs.platforms }}
          target: ${{ inputs.target }}
          provenance: true
          sbom: true
          push: ${{ inputs.push }}
      
      - name: Inspect image
        run: |
          docker image inspect ${{ inputs.image-name }}:${{ inputs.image-tags }}
      
      - name: Generate SBOM
        if: inputs.push == true
        uses: anchore/sbom-action@v0
        with:
          image: ${{ inputs.image-name }}:${{ inputs.image-tags }}
          format: spdx-json
          output-file: sbom.json
      
      - name: Upload SBOM
        if: inputs.push == true
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ inputs.image-name }}
          path: sbom.json
          retention-days: 30
      
      - name: Image scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ inputs.image-name }}:${{ inputs.image-tags }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
        continue-on-error: true
      
      - name: Upload Trivy scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
        if: always()
        continue-on-error: true
      
      - name: Check image size
        run: |
          SIZE=$(docker image inspect ${{ inputs.image-name }}:${{ inputs.image-tags }} --format='{{.Size}}')
          SIZE_MB=$((SIZE / 1024 / 1024))
          
          echo "## ðŸ“¦ Docker Image" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ inputs.image-name }}:${{ inputs.image-tags }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Digest:** \`${{ steps.build.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Size:** ${SIZE_MB} MB" >> $GITHUB_STEP_SUMMARY
          
          if [ "$SIZE_MB" -gt 500 ]; then
            echo "âš ï¸ Warning: Image size exceeds 500MB" >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Cache image layers
        if: inputs.cache-to == 'type=gha,mode=max'
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ inputs.image-name }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-${{ inputs.image-name }}-
        continue-on-error: true

  multi-arch-build:
    name: Multi-Arch Build (Optional)
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: build
    if: inputs.platforms != ''
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to registry
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ secrets.registry-username || github.actor }}
          password: ${{ secrets.registry-password || github.token }}
      
      - name: Build and push multi-arch image
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.docker-context }}
          file: ${{ inputs.docker-context }}/${{ inputs.dockerfile }}
          push: ${{ inputs.push }}
          tags: |
            ${{ inputs.image-name }}:${{ inputs.image-tags }}
            ${{ inputs.image-name }}:multiarch
          platforms: ${{ inputs.platforms }}
          cache-from: ${{ inputs.cache-from }}
          cache-to: ${{ inputs.cache-to }}
          output: type=image,push=true
        continue-on-error: true

  test-image:
    name: Test Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: build
    if: inputs.push == true
    
    container:
      image: ${{ inputs.image-name }}:${{ inputs.image-tags }}
    
    steps:
      - name: Verify image
        run: |
          echo "Testing Docker image..."
          
          # Check if the service can start
          if [ -f "package.json" ]; then
            echo "Node.js package found"
            node --version
            npm --version
          fi
          
          echo "âœ… Image verification passed"
    
      - name: Run health check (if applicable)
        run: |
          # Add specific health checks based on the image type
          if command -v curl &> /dev/null; then
            echo "curl is available for health checks"
          fi
          
          # Return success if no health check is configured
          exit 0
        continue-on-error: true
